/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export type GetClientSubscriptionsV1SearchRequest = {
  /**
   * Filter by subscription IDs
   */
  tokens?: string | undefined;
  /**
   * Filter by plan IDs
   */
  planIds?: string | undefined;
  /**
   * Filter by User IDs
   */
  userIds?: string | undefined;
  /**
   * Filter by statuses
   */
  statuses?: string | undefined;
  /**
   * Limit search results to a value
   */
  limit?: string | undefined;
  /**
   * Paginate search results
   */
  page?: string | undefined;
  /**
   * Sort by specifies the field use to sort data e.g. `created_at`
   */
  sortBy?: string | undefined;
  /**
   * Direction specifies the data sort order either ASC or DESC
   */
  direction?: string | undefined;
};

export type GetClientSubscriptionsV1SearchPlanPriceMoney = {
  amount?: string | undefined;
  currency?: string | undefined;
};

export type GetClientSubscriptionsV1SearchPlan = {
  active?: boolean | undefined;
  amount?: string | undefined;
  applyAmountChangeOnExistingSubscriptions?: boolean | undefined;
  archived?: boolean | undefined;
  createdAt?: Date | undefined;
  currency?: string | undefined;
  description?: string | undefined;
  interval?: string | undefined;
  intervalCount?: number | undefined;
  merchantApiKey?: string | undefined;
  name?: string | undefined;
  numberOfBillingCycles?: number | undefined;
  priceMoney?: GetClientSubscriptionsV1SearchPlanPriceMoney | undefined;
  product?: string | undefined;
  token?: string | undefined;
  trialPeriodDays?: number | undefined;
  type?: string | undefined;
  updatedAt?: Date | undefined;
};

export type GetClientSubscriptionsV1SearchPriceMoney = {
  amount?: string | undefined;
  currency?: string | undefined;
};

export type Subscription = {
  balance?: string | undefined;
  billingCycleAnchor?: Date | undefined;
  cancelAtPeriodEnd?: boolean | undefined;
  canceledAt?: Date | undefined;
  createdAt?: Date | undefined;
  currentPeriodEndDate?: Date | undefined;
  currentPeriodStartDate?: Date | undefined;
  instrumentId?: string | undefined;
  merchantApiKey?: string | undefined;
  neverExpires?: boolean | undefined;
  numberOfBillingCycles?: number | undefined;
  plan?: GetClientSubscriptionsV1SearchPlan | undefined;
  planId?: string | undefined;
  priceAmount?: string | undefined;
  priceCurrency?: string | undefined;
  priceMoney?: GetClientSubscriptionsV1SearchPriceMoney | undefined;
  startDate?: Date | undefined;
  status?: string | undefined;
  token?: string | undefined;
  trialEndDate?: Date | undefined;
  trialStartDate?: Date | undefined;
  updatedAt?: Date | undefined;
  userId?: string | undefined;
};

export type GetClientSubscriptionsV1SearchData = {
  count?: string | undefined;
  direction?: string | undefined;
  sortBy?: string | undefined;
  subscriptions?: Array<Subscription> | undefined;
};

/**
 * 200
 */
export type GetClientSubscriptionsV1SearchResponseBody = {
  data?: GetClientSubscriptionsV1SearchData | undefined;
  status?: models.Status | undefined;
};

export type GetClientSubscriptionsV1SearchResponse = {
  headers: { [k: string]: Array<string> };
  result: GetClientSubscriptionsV1SearchResponseBody;
};

/** @internal */
export const GetClientSubscriptionsV1SearchRequest$inboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  tokens: z.string().optional(),
  plan_ids: z.string().optional(),
  user_ids: z.string().optional(),
  statuses: z.string().optional(),
  limit: z.string().optional(),
  page: z.string().optional(),
  sort_by: z.string().optional(),
  direction: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "plan_ids": "planIds",
    "user_ids": "userIds",
    "sort_by": "sortBy",
  });
});

/** @internal */
export type GetClientSubscriptionsV1SearchRequest$Outbound = {
  tokens?: string | undefined;
  plan_ids?: string | undefined;
  user_ids?: string | undefined;
  statuses?: string | undefined;
  limit?: string | undefined;
  page?: string | undefined;
  sort_by?: string | undefined;
  direction?: string | undefined;
};

/** @internal */
export const GetClientSubscriptionsV1SearchRequest$outboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchRequest$Outbound,
  z.ZodTypeDef,
  GetClientSubscriptionsV1SearchRequest
> = z.object({
  tokens: z.string().optional(),
  planIds: z.string().optional(),
  userIds: z.string().optional(),
  statuses: z.string().optional(),
  limit: z.string().optional(),
  page: z.string().optional(),
  sortBy: z.string().optional(),
  direction: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    planIds: "plan_ids",
    userIds: "user_ids",
    sortBy: "sort_by",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetClientSubscriptionsV1SearchRequest$ {
  /** @deprecated use `GetClientSubscriptionsV1SearchRequest$inboundSchema` instead. */
  export const inboundSchema =
    GetClientSubscriptionsV1SearchRequest$inboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchRequest$outboundSchema` instead. */
  export const outboundSchema =
    GetClientSubscriptionsV1SearchRequest$outboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchRequest$Outbound` instead. */
  export type Outbound = GetClientSubscriptionsV1SearchRequest$Outbound;
}

export function getClientSubscriptionsV1SearchRequestToJSON(
  getClientSubscriptionsV1SearchRequest: GetClientSubscriptionsV1SearchRequest,
): string {
  return JSON.stringify(
    GetClientSubscriptionsV1SearchRequest$outboundSchema.parse(
      getClientSubscriptionsV1SearchRequest,
    ),
  );
}

export function getClientSubscriptionsV1SearchRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetClientSubscriptionsV1SearchRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetClientSubscriptionsV1SearchRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetClientSubscriptionsV1SearchRequest' from JSON`,
  );
}

/** @internal */
export const GetClientSubscriptionsV1SearchPlanPriceMoney$inboundSchema:
  z.ZodType<
    GetClientSubscriptionsV1SearchPlanPriceMoney,
    z.ZodTypeDef,
    unknown
  > = z.object({
    amount: z.string().optional(),
    currency: z.string().optional(),
  });

/** @internal */
export type GetClientSubscriptionsV1SearchPlanPriceMoney$Outbound = {
  amount?: string | undefined;
  currency?: string | undefined;
};

/** @internal */
export const GetClientSubscriptionsV1SearchPlanPriceMoney$outboundSchema:
  z.ZodType<
    GetClientSubscriptionsV1SearchPlanPriceMoney$Outbound,
    z.ZodTypeDef,
    GetClientSubscriptionsV1SearchPlanPriceMoney
  > = z.object({
    amount: z.string().optional(),
    currency: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetClientSubscriptionsV1SearchPlanPriceMoney$ {
  /** @deprecated use `GetClientSubscriptionsV1SearchPlanPriceMoney$inboundSchema` instead. */
  export const inboundSchema =
    GetClientSubscriptionsV1SearchPlanPriceMoney$inboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchPlanPriceMoney$outboundSchema` instead. */
  export const outboundSchema =
    GetClientSubscriptionsV1SearchPlanPriceMoney$outboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchPlanPriceMoney$Outbound` instead. */
  export type Outbound = GetClientSubscriptionsV1SearchPlanPriceMoney$Outbound;
}

export function getClientSubscriptionsV1SearchPlanPriceMoneyToJSON(
  getClientSubscriptionsV1SearchPlanPriceMoney:
    GetClientSubscriptionsV1SearchPlanPriceMoney,
): string {
  return JSON.stringify(
    GetClientSubscriptionsV1SearchPlanPriceMoney$outboundSchema.parse(
      getClientSubscriptionsV1SearchPlanPriceMoney,
    ),
  );
}

export function getClientSubscriptionsV1SearchPlanPriceMoneyFromJSON(
  jsonString: string,
): SafeParseResult<
  GetClientSubscriptionsV1SearchPlanPriceMoney,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetClientSubscriptionsV1SearchPlanPriceMoney$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetClientSubscriptionsV1SearchPlanPriceMoney' from JSON`,
  );
}

/** @internal */
export const GetClientSubscriptionsV1SearchPlan$inboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchPlan,
  z.ZodTypeDef,
  unknown
> = z.object({
  active: z.boolean().optional(),
  amount: z.string().optional(),
  apply_amount_change_on_existing_subscriptions: z.boolean().optional(),
  archived: z.boolean().optional(),
  created_at: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  currency: z.string().optional(),
  description: z.string().optional(),
  interval: z.string().optional(),
  interval_count: z.number().int().optional(),
  merchant_api_key: z.string().optional(),
  name: z.string().optional(),
  number_of_billing_cycles: z.number().int().optional(),
  price_money: z.lazy(() =>
    GetClientSubscriptionsV1SearchPlanPriceMoney$inboundSchema
  ).optional(),
  product: z.string().optional(),
  token: z.string().optional(),
  trial_period_days: z.number().int().optional(),
  type: z.string().optional(),
  updated_at: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "apply_amount_change_on_existing_subscriptions":
      "applyAmountChangeOnExistingSubscriptions",
    "created_at": "createdAt",
    "interval_count": "intervalCount",
    "merchant_api_key": "merchantApiKey",
    "number_of_billing_cycles": "numberOfBillingCycles",
    "price_money": "priceMoney",
    "trial_period_days": "trialPeriodDays",
    "updated_at": "updatedAt",
  });
});

/** @internal */
export type GetClientSubscriptionsV1SearchPlan$Outbound = {
  active?: boolean | undefined;
  amount?: string | undefined;
  apply_amount_change_on_existing_subscriptions?: boolean | undefined;
  archived?: boolean | undefined;
  created_at?: string | undefined;
  currency?: string | undefined;
  description?: string | undefined;
  interval?: string | undefined;
  interval_count?: number | undefined;
  merchant_api_key?: string | undefined;
  name?: string | undefined;
  number_of_billing_cycles?: number | undefined;
  price_money?:
    | GetClientSubscriptionsV1SearchPlanPriceMoney$Outbound
    | undefined;
  product?: string | undefined;
  token?: string | undefined;
  trial_period_days?: number | undefined;
  type?: string | undefined;
  updated_at?: string | undefined;
};

/** @internal */
export const GetClientSubscriptionsV1SearchPlan$outboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchPlan$Outbound,
  z.ZodTypeDef,
  GetClientSubscriptionsV1SearchPlan
> = z.object({
  active: z.boolean().optional(),
  amount: z.string().optional(),
  applyAmountChangeOnExistingSubscriptions: z.boolean().optional(),
  archived: z.boolean().optional(),
  createdAt: z.date().transform(v => v.toISOString()).optional(),
  currency: z.string().optional(),
  description: z.string().optional(),
  interval: z.string().optional(),
  intervalCount: z.number().int().optional(),
  merchantApiKey: z.string().optional(),
  name: z.string().optional(),
  numberOfBillingCycles: z.number().int().optional(),
  priceMoney: z.lazy(() =>
    GetClientSubscriptionsV1SearchPlanPriceMoney$outboundSchema
  ).optional(),
  product: z.string().optional(),
  token: z.string().optional(),
  trialPeriodDays: z.number().int().optional(),
  type: z.string().optional(),
  updatedAt: z.date().transform(v => v.toISOString()).optional(),
}).transform((v) => {
  return remap$(v, {
    applyAmountChangeOnExistingSubscriptions:
      "apply_amount_change_on_existing_subscriptions",
    createdAt: "created_at",
    intervalCount: "interval_count",
    merchantApiKey: "merchant_api_key",
    numberOfBillingCycles: "number_of_billing_cycles",
    priceMoney: "price_money",
    trialPeriodDays: "trial_period_days",
    updatedAt: "updated_at",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetClientSubscriptionsV1SearchPlan$ {
  /** @deprecated use `GetClientSubscriptionsV1SearchPlan$inboundSchema` instead. */
  export const inboundSchema = GetClientSubscriptionsV1SearchPlan$inboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchPlan$outboundSchema` instead. */
  export const outboundSchema =
    GetClientSubscriptionsV1SearchPlan$outboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchPlan$Outbound` instead. */
  export type Outbound = GetClientSubscriptionsV1SearchPlan$Outbound;
}

export function getClientSubscriptionsV1SearchPlanToJSON(
  getClientSubscriptionsV1SearchPlan: GetClientSubscriptionsV1SearchPlan,
): string {
  return JSON.stringify(
    GetClientSubscriptionsV1SearchPlan$outboundSchema.parse(
      getClientSubscriptionsV1SearchPlan,
    ),
  );
}

export function getClientSubscriptionsV1SearchPlanFromJSON(
  jsonString: string,
): SafeParseResult<GetClientSubscriptionsV1SearchPlan, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetClientSubscriptionsV1SearchPlan$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetClientSubscriptionsV1SearchPlan' from JSON`,
  );
}

/** @internal */
export const GetClientSubscriptionsV1SearchPriceMoney$inboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchPriceMoney,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.string().optional(),
  currency: z.string().optional(),
});

/** @internal */
export type GetClientSubscriptionsV1SearchPriceMoney$Outbound = {
  amount?: string | undefined;
  currency?: string | undefined;
};

/** @internal */
export const GetClientSubscriptionsV1SearchPriceMoney$outboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchPriceMoney$Outbound,
  z.ZodTypeDef,
  GetClientSubscriptionsV1SearchPriceMoney
> = z.object({
  amount: z.string().optional(),
  currency: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetClientSubscriptionsV1SearchPriceMoney$ {
  /** @deprecated use `GetClientSubscriptionsV1SearchPriceMoney$inboundSchema` instead. */
  export const inboundSchema =
    GetClientSubscriptionsV1SearchPriceMoney$inboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchPriceMoney$outboundSchema` instead. */
  export const outboundSchema =
    GetClientSubscriptionsV1SearchPriceMoney$outboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchPriceMoney$Outbound` instead. */
  export type Outbound = GetClientSubscriptionsV1SearchPriceMoney$Outbound;
}

export function getClientSubscriptionsV1SearchPriceMoneyToJSON(
  getClientSubscriptionsV1SearchPriceMoney:
    GetClientSubscriptionsV1SearchPriceMoney,
): string {
  return JSON.stringify(
    GetClientSubscriptionsV1SearchPriceMoney$outboundSchema.parse(
      getClientSubscriptionsV1SearchPriceMoney,
    ),
  );
}

export function getClientSubscriptionsV1SearchPriceMoneyFromJSON(
  jsonString: string,
): SafeParseResult<
  GetClientSubscriptionsV1SearchPriceMoney,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetClientSubscriptionsV1SearchPriceMoney$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetClientSubscriptionsV1SearchPriceMoney' from JSON`,
  );
}

/** @internal */
export const Subscription$inboundSchema: z.ZodType<
  Subscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  balance: z.string().optional(),
  billing_cycle_anchor: z.string().datetime({ offset: true }).transform(v =>
    new Date(v)
  ).optional(),
  cancel_at_period_end: z.boolean().optional(),
  canceled_at: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  created_at: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  current_period_end_date: z.string().datetime({ offset: true }).transform(v =>
    new Date(v)
  ).optional(),
  current_period_start_date: z.string().datetime({ offset: true }).transform(
    v => new Date(v)
  ).optional(),
  instrument_id: z.string().optional(),
  merchant_api_key: z.string().optional(),
  never_expires: z.boolean().optional(),
  number_of_billing_cycles: z.number().int().optional(),
  plan: z.lazy(() => GetClientSubscriptionsV1SearchPlan$inboundSchema)
    .optional(),
  plan_id: z.string().optional(),
  price_amount: z.string().optional(),
  price_currency: z.string().optional(),
  price_money: z.lazy(() =>
    GetClientSubscriptionsV1SearchPriceMoney$inboundSchema
  ).optional(),
  start_date: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  status: z.string().optional(),
  token: z.string().optional(),
  trial_end_date: z.string().datetime({ offset: true }).transform(v =>
    new Date(v)
  ).optional(),
  trial_start_date: z.string().datetime({ offset: true }).transform(v =>
    new Date(v)
  ).optional(),
  updated_at: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  user_id: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "billing_cycle_anchor": "billingCycleAnchor",
    "cancel_at_period_end": "cancelAtPeriodEnd",
    "canceled_at": "canceledAt",
    "created_at": "createdAt",
    "current_period_end_date": "currentPeriodEndDate",
    "current_period_start_date": "currentPeriodStartDate",
    "instrument_id": "instrumentId",
    "merchant_api_key": "merchantApiKey",
    "never_expires": "neverExpires",
    "number_of_billing_cycles": "numberOfBillingCycles",
    "plan_id": "planId",
    "price_amount": "priceAmount",
    "price_currency": "priceCurrency",
    "price_money": "priceMoney",
    "start_date": "startDate",
    "trial_end_date": "trialEndDate",
    "trial_start_date": "trialStartDate",
    "updated_at": "updatedAt",
    "user_id": "userId",
  });
});

/** @internal */
export type Subscription$Outbound = {
  balance?: string | undefined;
  billing_cycle_anchor?: string | undefined;
  cancel_at_period_end?: boolean | undefined;
  canceled_at?: string | undefined;
  created_at?: string | undefined;
  current_period_end_date?: string | undefined;
  current_period_start_date?: string | undefined;
  instrument_id?: string | undefined;
  merchant_api_key?: string | undefined;
  never_expires?: boolean | undefined;
  number_of_billing_cycles?: number | undefined;
  plan?: GetClientSubscriptionsV1SearchPlan$Outbound | undefined;
  plan_id?: string | undefined;
  price_amount?: string | undefined;
  price_currency?: string | undefined;
  price_money?: GetClientSubscriptionsV1SearchPriceMoney$Outbound | undefined;
  start_date?: string | undefined;
  status?: string | undefined;
  token?: string | undefined;
  trial_end_date?: string | undefined;
  trial_start_date?: string | undefined;
  updated_at?: string | undefined;
  user_id?: string | undefined;
};

/** @internal */
export const Subscription$outboundSchema: z.ZodType<
  Subscription$Outbound,
  z.ZodTypeDef,
  Subscription
> = z.object({
  balance: z.string().optional(),
  billingCycleAnchor: z.date().transform(v => v.toISOString()).optional(),
  cancelAtPeriodEnd: z.boolean().optional(),
  canceledAt: z.date().transform(v => v.toISOString()).optional(),
  createdAt: z.date().transform(v => v.toISOString()).optional(),
  currentPeriodEndDate: z.date().transform(v => v.toISOString()).optional(),
  currentPeriodStartDate: z.date().transform(v => v.toISOString()).optional(),
  instrumentId: z.string().optional(),
  merchantApiKey: z.string().optional(),
  neverExpires: z.boolean().optional(),
  numberOfBillingCycles: z.number().int().optional(),
  plan: z.lazy(() => GetClientSubscriptionsV1SearchPlan$outboundSchema)
    .optional(),
  planId: z.string().optional(),
  priceAmount: z.string().optional(),
  priceCurrency: z.string().optional(),
  priceMoney: z.lazy(() =>
    GetClientSubscriptionsV1SearchPriceMoney$outboundSchema
  ).optional(),
  startDate: z.date().transform(v => v.toISOString()).optional(),
  status: z.string().optional(),
  token: z.string().optional(),
  trialEndDate: z.date().transform(v => v.toISOString()).optional(),
  trialStartDate: z.date().transform(v => v.toISOString()).optional(),
  updatedAt: z.date().transform(v => v.toISOString()).optional(),
  userId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    billingCycleAnchor: "billing_cycle_anchor",
    cancelAtPeriodEnd: "cancel_at_period_end",
    canceledAt: "canceled_at",
    createdAt: "created_at",
    currentPeriodEndDate: "current_period_end_date",
    currentPeriodStartDate: "current_period_start_date",
    instrumentId: "instrument_id",
    merchantApiKey: "merchant_api_key",
    neverExpires: "never_expires",
    numberOfBillingCycles: "number_of_billing_cycles",
    planId: "plan_id",
    priceAmount: "price_amount",
    priceCurrency: "price_currency",
    priceMoney: "price_money",
    startDate: "start_date",
    trialEndDate: "trial_end_date",
    trialStartDate: "trial_start_date",
    updatedAt: "updated_at",
    userId: "user_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Subscription$ {
  /** @deprecated use `Subscription$inboundSchema` instead. */
  export const inboundSchema = Subscription$inboundSchema;
  /** @deprecated use `Subscription$outboundSchema` instead. */
  export const outboundSchema = Subscription$outboundSchema;
  /** @deprecated use `Subscription$Outbound` instead. */
  export type Outbound = Subscription$Outbound;
}

export function subscriptionToJSON(subscription: Subscription): string {
  return JSON.stringify(Subscription$outboundSchema.parse(subscription));
}

export function subscriptionFromJSON(
  jsonString: string,
): SafeParseResult<Subscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Subscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Subscription' from JSON`,
  );
}

/** @internal */
export const GetClientSubscriptionsV1SearchData$inboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchData,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.string().optional(),
  direction: z.string().optional(),
  sort_by: z.string().optional(),
  subscriptions: z.array(z.lazy(() => Subscription$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "sort_by": "sortBy",
  });
});

/** @internal */
export type GetClientSubscriptionsV1SearchData$Outbound = {
  count?: string | undefined;
  direction?: string | undefined;
  sort_by?: string | undefined;
  subscriptions?: Array<Subscription$Outbound> | undefined;
};

/** @internal */
export const GetClientSubscriptionsV1SearchData$outboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchData$Outbound,
  z.ZodTypeDef,
  GetClientSubscriptionsV1SearchData
> = z.object({
  count: z.string().optional(),
  direction: z.string().optional(),
  sortBy: z.string().optional(),
  subscriptions: z.array(z.lazy(() => Subscription$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    sortBy: "sort_by",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetClientSubscriptionsV1SearchData$ {
  /** @deprecated use `GetClientSubscriptionsV1SearchData$inboundSchema` instead. */
  export const inboundSchema = GetClientSubscriptionsV1SearchData$inboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchData$outboundSchema` instead. */
  export const outboundSchema =
    GetClientSubscriptionsV1SearchData$outboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchData$Outbound` instead. */
  export type Outbound = GetClientSubscriptionsV1SearchData$Outbound;
}

export function getClientSubscriptionsV1SearchDataToJSON(
  getClientSubscriptionsV1SearchData: GetClientSubscriptionsV1SearchData,
): string {
  return JSON.stringify(
    GetClientSubscriptionsV1SearchData$outboundSchema.parse(
      getClientSubscriptionsV1SearchData,
    ),
  );
}

export function getClientSubscriptionsV1SearchDataFromJSON(
  jsonString: string,
): SafeParseResult<GetClientSubscriptionsV1SearchData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetClientSubscriptionsV1SearchData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetClientSubscriptionsV1SearchData' from JSON`,
  );
}

/** @internal */
export const GetClientSubscriptionsV1SearchResponseBody$inboundSchema:
  z.ZodType<GetClientSubscriptionsV1SearchResponseBody, z.ZodTypeDef, unknown> =
    z.object({
      data: z.lazy(() => GetClientSubscriptionsV1SearchData$inboundSchema)
        .optional(),
      status: models.Status$inboundSchema.optional(),
    });

/** @internal */
export type GetClientSubscriptionsV1SearchResponseBody$Outbound = {
  data?: GetClientSubscriptionsV1SearchData$Outbound | undefined;
  status?: models.Status$Outbound | undefined;
};

/** @internal */
export const GetClientSubscriptionsV1SearchResponseBody$outboundSchema:
  z.ZodType<
    GetClientSubscriptionsV1SearchResponseBody$Outbound,
    z.ZodTypeDef,
    GetClientSubscriptionsV1SearchResponseBody
  > = z.object({
    data: z.lazy(() => GetClientSubscriptionsV1SearchData$outboundSchema)
      .optional(),
    status: models.Status$outboundSchema.optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetClientSubscriptionsV1SearchResponseBody$ {
  /** @deprecated use `GetClientSubscriptionsV1SearchResponseBody$inboundSchema` instead. */
  export const inboundSchema =
    GetClientSubscriptionsV1SearchResponseBody$inboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchResponseBody$outboundSchema` instead. */
  export const outboundSchema =
    GetClientSubscriptionsV1SearchResponseBody$outboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchResponseBody$Outbound` instead. */
  export type Outbound = GetClientSubscriptionsV1SearchResponseBody$Outbound;
}

export function getClientSubscriptionsV1SearchResponseBodyToJSON(
  getClientSubscriptionsV1SearchResponseBody:
    GetClientSubscriptionsV1SearchResponseBody,
): string {
  return JSON.stringify(
    GetClientSubscriptionsV1SearchResponseBody$outboundSchema.parse(
      getClientSubscriptionsV1SearchResponseBody,
    ),
  );
}

export function getClientSubscriptionsV1SearchResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  GetClientSubscriptionsV1SearchResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetClientSubscriptionsV1SearchResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetClientSubscriptionsV1SearchResponseBody' from JSON`,
  );
}

/** @internal */
export const GetClientSubscriptionsV1SearchResponse$inboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  Headers: z.record(z.array(z.string())),
  Result: z.lazy(() =>
    GetClientSubscriptionsV1SearchResponseBody$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "Headers": "headers",
    "Result": "result",
  });
});

/** @internal */
export type GetClientSubscriptionsV1SearchResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: GetClientSubscriptionsV1SearchResponseBody$Outbound;
};

/** @internal */
export const GetClientSubscriptionsV1SearchResponse$outboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchResponse$Outbound,
  z.ZodTypeDef,
  GetClientSubscriptionsV1SearchResponse
> = z.object({
  headers: z.record(z.array(z.string())),
  result: z.lazy(() =>
    GetClientSubscriptionsV1SearchResponseBody$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    headers: "Headers",
    result: "Result",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetClientSubscriptionsV1SearchResponse$ {
  /** @deprecated use `GetClientSubscriptionsV1SearchResponse$inboundSchema` instead. */
  export const inboundSchema =
    GetClientSubscriptionsV1SearchResponse$inboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchResponse$outboundSchema` instead. */
  export const outboundSchema =
    GetClientSubscriptionsV1SearchResponse$outboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchResponse$Outbound` instead. */
  export type Outbound = GetClientSubscriptionsV1SearchResponse$Outbound;
}

export function getClientSubscriptionsV1SearchResponseToJSON(
  getClientSubscriptionsV1SearchResponse:
    GetClientSubscriptionsV1SearchResponse,
): string {
  return JSON.stringify(
    GetClientSubscriptionsV1SearchResponse$outboundSchema.parse(
      getClientSubscriptionsV1SearchResponse,
    ),
  );
}

export function getClientSubscriptionsV1SearchResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetClientSubscriptionsV1SearchResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetClientSubscriptionsV1SearchResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetClientSubscriptionsV1SearchResponse' from JSON`,
  );
}
