/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GetClientSubscriptionsV1SearchRequest = {
  /**
   * Filter by subscription IDs
   */
  tokens?: string | undefined;
  /**
   * Filter by plan IDs
   */
  planIds?: string | undefined;
  /**
   * Filter by User IDs
   */
  userIds?: string | undefined;
  /**
   * Filter by statuses
   */
  statuses?: string | undefined;
  /**
   * Limit search results to a value
   */
  limit?: string | undefined;
  /**
   * Paginate search results
   */
  page?: string | undefined;
  /**
   * Sort by specifies the field use to sort data e.g. `created_at`
   */
  sortBy?: string | undefined;
  /**
   * Direction specifies the data sort order either ASC or DESC
   */
  direction?: string | undefined;
};

export type GetClientSubscriptionsV1SearchStatus = {
  errors?: Array<string> | undefined;
  message?: string | undefined;
};

export type GetClientSubscriptionsV1SearchPlanPriceMoney = {
  currency?: string | undefined;
  amount?: string | undefined;
};

export type GetClientSubscriptionsV1SearchPlan = {
  token?: string | undefined;
  merchantApiKey?: string | undefined;
  name?: string | undefined;
  amount?: string | undefined;
  currency?: string | undefined;
  intervalCount?: number | undefined;
  interval?: string | undefined;
  product?: string | undefined;
  type?: string | undefined;
  trialPeriodDays?: number | undefined;
  description?: string | undefined;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  active?: boolean | undefined;
  archived?: boolean | undefined;
  numberOfBillingCycles?: number | undefined;
  applyAmountChangeOnExistingSubscriptions?: boolean | undefined;
  priceMoney?: GetClientSubscriptionsV1SearchPlanPriceMoney | undefined;
};

export type GetClientSubscriptionsV1SearchPriceMoney = {
  currency?: string | undefined;
  amount?: string | undefined;
};

export type GetClientSubscriptionsV1SearchSubscription = {
  token?: string | undefined;
  planId?: string | undefined;
  userId?: string | undefined;
  instrumentId?: string | undefined;
  status?: string | undefined;
  billingCycleAnchor?: Date | undefined;
  priceAmount?: string | undefined;
  priceCurrency?: string | undefined;
  balance?: string | undefined;
  startDate?: Date | undefined;
  trialStartDate?: Date | undefined;
  trialEndDate?: Date | undefined;
  cancelAtPeriodEnd?: boolean | undefined;
  canceledAt?: Date | undefined;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  plan?: GetClientSubscriptionsV1SearchPlan | undefined;
  currentPeriodStartDate?: Date | undefined;
  currentPeriodEndDate?: Date | undefined;
  neverExpires?: boolean | undefined;
  numberOfBillingCycles?: number | undefined;
  merchantApiKey?: string | undefined;
  priceMoney?: GetClientSubscriptionsV1SearchPriceMoney | undefined;
};

export type GetClientSubscriptionsV1SearchData = {
  subscriptions?: Array<GetClientSubscriptionsV1SearchSubscription> | undefined;
  count?: string | undefined;
  direction?: string | undefined;
  sortBy?: string | undefined;
};

/**
 * 200
 */
export type GetClientSubscriptionsV1SearchResponseBody = {
  data?: GetClientSubscriptionsV1SearchData | undefined;
};

export type GetClientSubscriptionsV1SearchResponse = {
  headers: { [k: string]: Array<string> };
  result: GetClientSubscriptionsV1SearchResponseBody;
};

/** @internal */
export const GetClientSubscriptionsV1SearchRequest$inboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  tokens: z.string().optional(),
  plan_ids: z.string().optional(),
  user_ids: z.string().optional(),
  statuses: z.string().optional(),
  limit: z.string().optional(),
  page: z.string().optional(),
  sort_by: z.string().optional(),
  direction: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "plan_ids": "planIds",
    "user_ids": "userIds",
    "sort_by": "sortBy",
  });
});

/** @internal */
export type GetClientSubscriptionsV1SearchRequest$Outbound = {
  tokens?: string | undefined;
  plan_ids?: string | undefined;
  user_ids?: string | undefined;
  statuses?: string | undefined;
  limit?: string | undefined;
  page?: string | undefined;
  sort_by?: string | undefined;
  direction?: string | undefined;
};

/** @internal */
export const GetClientSubscriptionsV1SearchRequest$outboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchRequest$Outbound,
  z.ZodTypeDef,
  GetClientSubscriptionsV1SearchRequest
> = z.object({
  tokens: z.string().optional(),
  planIds: z.string().optional(),
  userIds: z.string().optional(),
  statuses: z.string().optional(),
  limit: z.string().optional(),
  page: z.string().optional(),
  sortBy: z.string().optional(),
  direction: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    planIds: "plan_ids",
    userIds: "user_ids",
    sortBy: "sort_by",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetClientSubscriptionsV1SearchRequest$ {
  /** @deprecated use `GetClientSubscriptionsV1SearchRequest$inboundSchema` instead. */
  export const inboundSchema =
    GetClientSubscriptionsV1SearchRequest$inboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchRequest$outboundSchema` instead. */
  export const outboundSchema =
    GetClientSubscriptionsV1SearchRequest$outboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchRequest$Outbound` instead. */
  export type Outbound = GetClientSubscriptionsV1SearchRequest$Outbound;
}

export function getClientSubscriptionsV1SearchRequestToJSON(
  getClientSubscriptionsV1SearchRequest: GetClientSubscriptionsV1SearchRequest,
): string {
  return JSON.stringify(
    GetClientSubscriptionsV1SearchRequest$outboundSchema.parse(
      getClientSubscriptionsV1SearchRequest,
    ),
  );
}

export function getClientSubscriptionsV1SearchRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetClientSubscriptionsV1SearchRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetClientSubscriptionsV1SearchRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetClientSubscriptionsV1SearchRequest' from JSON`,
  );
}

/** @internal */
export const GetClientSubscriptionsV1SearchStatus$inboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchStatus,
  z.ZodTypeDef,
  unknown
> = z.object({
  errors: z.array(z.string()).optional(),
  message: z.string().optional(),
});

/** @internal */
export type GetClientSubscriptionsV1SearchStatus$Outbound = {
  errors?: Array<string> | undefined;
  message?: string | undefined;
};

/** @internal */
export const GetClientSubscriptionsV1SearchStatus$outboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchStatus$Outbound,
  z.ZodTypeDef,
  GetClientSubscriptionsV1SearchStatus
> = z.object({
  errors: z.array(z.string()).optional(),
  message: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetClientSubscriptionsV1SearchStatus$ {
  /** @deprecated use `GetClientSubscriptionsV1SearchStatus$inboundSchema` instead. */
  export const inboundSchema =
    GetClientSubscriptionsV1SearchStatus$inboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchStatus$outboundSchema` instead. */
  export const outboundSchema =
    GetClientSubscriptionsV1SearchStatus$outboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchStatus$Outbound` instead. */
  export type Outbound = GetClientSubscriptionsV1SearchStatus$Outbound;
}

export function getClientSubscriptionsV1SearchStatusToJSON(
  getClientSubscriptionsV1SearchStatus: GetClientSubscriptionsV1SearchStatus,
): string {
  return JSON.stringify(
    GetClientSubscriptionsV1SearchStatus$outboundSchema.parse(
      getClientSubscriptionsV1SearchStatus,
    ),
  );
}

export function getClientSubscriptionsV1SearchStatusFromJSON(
  jsonString: string,
): SafeParseResult<GetClientSubscriptionsV1SearchStatus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetClientSubscriptionsV1SearchStatus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetClientSubscriptionsV1SearchStatus' from JSON`,
  );
}

/** @internal */
export const GetClientSubscriptionsV1SearchPlanPriceMoney$inboundSchema:
  z.ZodType<
    GetClientSubscriptionsV1SearchPlanPriceMoney,
    z.ZodTypeDef,
    unknown
  > = z.object({
    currency: z.string().optional(),
    amount: z.string().optional(),
  });

/** @internal */
export type GetClientSubscriptionsV1SearchPlanPriceMoney$Outbound = {
  currency?: string | undefined;
  amount?: string | undefined;
};

/** @internal */
export const GetClientSubscriptionsV1SearchPlanPriceMoney$outboundSchema:
  z.ZodType<
    GetClientSubscriptionsV1SearchPlanPriceMoney$Outbound,
    z.ZodTypeDef,
    GetClientSubscriptionsV1SearchPlanPriceMoney
  > = z.object({
    currency: z.string().optional(),
    amount: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetClientSubscriptionsV1SearchPlanPriceMoney$ {
  /** @deprecated use `GetClientSubscriptionsV1SearchPlanPriceMoney$inboundSchema` instead. */
  export const inboundSchema =
    GetClientSubscriptionsV1SearchPlanPriceMoney$inboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchPlanPriceMoney$outboundSchema` instead. */
  export const outboundSchema =
    GetClientSubscriptionsV1SearchPlanPriceMoney$outboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchPlanPriceMoney$Outbound` instead. */
  export type Outbound = GetClientSubscriptionsV1SearchPlanPriceMoney$Outbound;
}

export function getClientSubscriptionsV1SearchPlanPriceMoneyToJSON(
  getClientSubscriptionsV1SearchPlanPriceMoney:
    GetClientSubscriptionsV1SearchPlanPriceMoney,
): string {
  return JSON.stringify(
    GetClientSubscriptionsV1SearchPlanPriceMoney$outboundSchema.parse(
      getClientSubscriptionsV1SearchPlanPriceMoney,
    ),
  );
}

export function getClientSubscriptionsV1SearchPlanPriceMoneyFromJSON(
  jsonString: string,
): SafeParseResult<
  GetClientSubscriptionsV1SearchPlanPriceMoney,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetClientSubscriptionsV1SearchPlanPriceMoney$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetClientSubscriptionsV1SearchPlanPriceMoney' from JSON`,
  );
}

/** @internal */
export const GetClientSubscriptionsV1SearchPlan$inboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchPlan,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string().optional(),
  merchant_api_key: z.string().optional(),
  name: z.string().optional(),
  amount: z.string().optional(),
  currency: z.string().optional(),
  interval_count: z.number().int().optional(),
  interval: z.string().optional(),
  product: z.string().optional(),
  type: z.string().optional(),
  trial_period_days: z.number().int().optional(),
  description: z.string().optional(),
  created_at: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  updated_at: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  active: z.boolean().optional(),
  archived: z.boolean().optional(),
  number_of_billing_cycles: z.number().int().optional(),
  apply_amount_change_on_existing_subscriptions: z.boolean().optional(),
  price_money: z.lazy(() =>
    GetClientSubscriptionsV1SearchPlanPriceMoney$inboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "merchant_api_key": "merchantApiKey",
    "interval_count": "intervalCount",
    "trial_period_days": "trialPeriodDays",
    "created_at": "createdAt",
    "updated_at": "updatedAt",
    "number_of_billing_cycles": "numberOfBillingCycles",
    "apply_amount_change_on_existing_subscriptions":
      "applyAmountChangeOnExistingSubscriptions",
    "price_money": "priceMoney",
  });
});

/** @internal */
export type GetClientSubscriptionsV1SearchPlan$Outbound = {
  token?: string | undefined;
  merchant_api_key?: string | undefined;
  name?: string | undefined;
  amount?: string | undefined;
  currency?: string | undefined;
  interval_count?: number | undefined;
  interval?: string | undefined;
  product?: string | undefined;
  type?: string | undefined;
  trial_period_days?: number | undefined;
  description?: string | undefined;
  created_at?: string | undefined;
  updated_at?: string | undefined;
  active?: boolean | undefined;
  archived?: boolean | undefined;
  number_of_billing_cycles?: number | undefined;
  apply_amount_change_on_existing_subscriptions?: boolean | undefined;
  price_money?:
    | GetClientSubscriptionsV1SearchPlanPriceMoney$Outbound
    | undefined;
};

/** @internal */
export const GetClientSubscriptionsV1SearchPlan$outboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchPlan$Outbound,
  z.ZodTypeDef,
  GetClientSubscriptionsV1SearchPlan
> = z.object({
  token: z.string().optional(),
  merchantApiKey: z.string().optional(),
  name: z.string().optional(),
  amount: z.string().optional(),
  currency: z.string().optional(),
  intervalCount: z.number().int().optional(),
  interval: z.string().optional(),
  product: z.string().optional(),
  type: z.string().optional(),
  trialPeriodDays: z.number().int().optional(),
  description: z.string().optional(),
  createdAt: z.date().transform(v => v.toISOString()).optional(),
  updatedAt: z.date().transform(v => v.toISOString()).optional(),
  active: z.boolean().optional(),
  archived: z.boolean().optional(),
  numberOfBillingCycles: z.number().int().optional(),
  applyAmountChangeOnExistingSubscriptions: z.boolean().optional(),
  priceMoney: z.lazy(() =>
    GetClientSubscriptionsV1SearchPlanPriceMoney$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    merchantApiKey: "merchant_api_key",
    intervalCount: "interval_count",
    trialPeriodDays: "trial_period_days",
    createdAt: "created_at",
    updatedAt: "updated_at",
    numberOfBillingCycles: "number_of_billing_cycles",
    applyAmountChangeOnExistingSubscriptions:
      "apply_amount_change_on_existing_subscriptions",
    priceMoney: "price_money",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetClientSubscriptionsV1SearchPlan$ {
  /** @deprecated use `GetClientSubscriptionsV1SearchPlan$inboundSchema` instead. */
  export const inboundSchema = GetClientSubscriptionsV1SearchPlan$inboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchPlan$outboundSchema` instead. */
  export const outboundSchema =
    GetClientSubscriptionsV1SearchPlan$outboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchPlan$Outbound` instead. */
  export type Outbound = GetClientSubscriptionsV1SearchPlan$Outbound;
}

export function getClientSubscriptionsV1SearchPlanToJSON(
  getClientSubscriptionsV1SearchPlan: GetClientSubscriptionsV1SearchPlan,
): string {
  return JSON.stringify(
    GetClientSubscriptionsV1SearchPlan$outboundSchema.parse(
      getClientSubscriptionsV1SearchPlan,
    ),
  );
}

export function getClientSubscriptionsV1SearchPlanFromJSON(
  jsonString: string,
): SafeParseResult<GetClientSubscriptionsV1SearchPlan, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetClientSubscriptionsV1SearchPlan$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetClientSubscriptionsV1SearchPlan' from JSON`,
  );
}

/** @internal */
export const GetClientSubscriptionsV1SearchPriceMoney$inboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchPriceMoney,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string().optional(),
  amount: z.string().optional(),
});

/** @internal */
export type GetClientSubscriptionsV1SearchPriceMoney$Outbound = {
  currency?: string | undefined;
  amount?: string | undefined;
};

/** @internal */
export const GetClientSubscriptionsV1SearchPriceMoney$outboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchPriceMoney$Outbound,
  z.ZodTypeDef,
  GetClientSubscriptionsV1SearchPriceMoney
> = z.object({
  currency: z.string().optional(),
  amount: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetClientSubscriptionsV1SearchPriceMoney$ {
  /** @deprecated use `GetClientSubscriptionsV1SearchPriceMoney$inboundSchema` instead. */
  export const inboundSchema =
    GetClientSubscriptionsV1SearchPriceMoney$inboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchPriceMoney$outboundSchema` instead. */
  export const outboundSchema =
    GetClientSubscriptionsV1SearchPriceMoney$outboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchPriceMoney$Outbound` instead. */
  export type Outbound = GetClientSubscriptionsV1SearchPriceMoney$Outbound;
}

export function getClientSubscriptionsV1SearchPriceMoneyToJSON(
  getClientSubscriptionsV1SearchPriceMoney:
    GetClientSubscriptionsV1SearchPriceMoney,
): string {
  return JSON.stringify(
    GetClientSubscriptionsV1SearchPriceMoney$outboundSchema.parse(
      getClientSubscriptionsV1SearchPriceMoney,
    ),
  );
}

export function getClientSubscriptionsV1SearchPriceMoneyFromJSON(
  jsonString: string,
): SafeParseResult<
  GetClientSubscriptionsV1SearchPriceMoney,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetClientSubscriptionsV1SearchPriceMoney$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetClientSubscriptionsV1SearchPriceMoney' from JSON`,
  );
}

/** @internal */
export const GetClientSubscriptionsV1SearchSubscription$inboundSchema:
  z.ZodType<GetClientSubscriptionsV1SearchSubscription, z.ZodTypeDef, unknown> =
    z.object({
      token: z.string().optional(),
      plan_id: z.string().optional(),
      user_id: z.string().optional(),
      instrument_id: z.string().optional(),
      status: z.string().optional(),
      billing_cycle_anchor: z.string().datetime({ offset: true }).transform(v =>
        new Date(v)
      ).optional(),
      price_amount: z.string().optional(),
      price_currency: z.string().optional(),
      balance: z.string().optional(),
      start_date: z.string().datetime({ offset: true }).transform(v =>
        new Date(v)
      ).optional(),
      trial_start_date: z.string().datetime({ offset: true }).transform(v =>
        new Date(v)
      ).optional(),
      trial_end_date: z.string().datetime({ offset: true }).transform(v =>
        new Date(v)
      ).optional(),
      cancel_at_period_end: z.boolean().optional(),
      canceled_at: z.string().datetime({ offset: true }).transform(v =>
        new Date(v)
      ).optional(),
      created_at: z.string().datetime({ offset: true }).transform(v =>
        new Date(v)
      ).optional(),
      updated_at: z.string().datetime({ offset: true }).transform(v =>
        new Date(v)
      ).optional(),
      plan: z.lazy(() => GetClientSubscriptionsV1SearchPlan$inboundSchema)
        .optional(),
      current_period_start_date: z.string().datetime({ offset: true })
        .transform(v => new Date(v)).optional(),
      current_period_end_date: z.string().datetime({ offset: true }).transform(
        v => new Date(v)
      ).optional(),
      never_expires: z.boolean().optional(),
      number_of_billing_cycles: z.number().int().optional(),
      merchant_api_key: z.string().optional(),
      price_money: z.lazy(() =>
        GetClientSubscriptionsV1SearchPriceMoney$inboundSchema
      ).optional(),
    }).transform((v) => {
      return remap$(v, {
        "plan_id": "planId",
        "user_id": "userId",
        "instrument_id": "instrumentId",
        "billing_cycle_anchor": "billingCycleAnchor",
        "price_amount": "priceAmount",
        "price_currency": "priceCurrency",
        "start_date": "startDate",
        "trial_start_date": "trialStartDate",
        "trial_end_date": "trialEndDate",
        "cancel_at_period_end": "cancelAtPeriodEnd",
        "canceled_at": "canceledAt",
        "created_at": "createdAt",
        "updated_at": "updatedAt",
        "current_period_start_date": "currentPeriodStartDate",
        "current_period_end_date": "currentPeriodEndDate",
        "never_expires": "neverExpires",
        "number_of_billing_cycles": "numberOfBillingCycles",
        "merchant_api_key": "merchantApiKey",
        "price_money": "priceMoney",
      });
    });

/** @internal */
export type GetClientSubscriptionsV1SearchSubscription$Outbound = {
  token?: string | undefined;
  plan_id?: string | undefined;
  user_id?: string | undefined;
  instrument_id?: string | undefined;
  status?: string | undefined;
  billing_cycle_anchor?: string | undefined;
  price_amount?: string | undefined;
  price_currency?: string | undefined;
  balance?: string | undefined;
  start_date?: string | undefined;
  trial_start_date?: string | undefined;
  trial_end_date?: string | undefined;
  cancel_at_period_end?: boolean | undefined;
  canceled_at?: string | undefined;
  created_at?: string | undefined;
  updated_at?: string | undefined;
  plan?: GetClientSubscriptionsV1SearchPlan$Outbound | undefined;
  current_period_start_date?: string | undefined;
  current_period_end_date?: string | undefined;
  never_expires?: boolean | undefined;
  number_of_billing_cycles?: number | undefined;
  merchant_api_key?: string | undefined;
  price_money?: GetClientSubscriptionsV1SearchPriceMoney$Outbound | undefined;
};

/** @internal */
export const GetClientSubscriptionsV1SearchSubscription$outboundSchema:
  z.ZodType<
    GetClientSubscriptionsV1SearchSubscription$Outbound,
    z.ZodTypeDef,
    GetClientSubscriptionsV1SearchSubscription
  > = z.object({
    token: z.string().optional(),
    planId: z.string().optional(),
    userId: z.string().optional(),
    instrumentId: z.string().optional(),
    status: z.string().optional(),
    billingCycleAnchor: z.date().transform(v => v.toISOString()).optional(),
    priceAmount: z.string().optional(),
    priceCurrency: z.string().optional(),
    balance: z.string().optional(),
    startDate: z.date().transform(v => v.toISOString()).optional(),
    trialStartDate: z.date().transform(v => v.toISOString()).optional(),
    trialEndDate: z.date().transform(v => v.toISOString()).optional(),
    cancelAtPeriodEnd: z.boolean().optional(),
    canceledAt: z.date().transform(v => v.toISOString()).optional(),
    createdAt: z.date().transform(v => v.toISOString()).optional(),
    updatedAt: z.date().transform(v => v.toISOString()).optional(),
    plan: z.lazy(() => GetClientSubscriptionsV1SearchPlan$outboundSchema)
      .optional(),
    currentPeriodStartDate: z.date().transform(v => v.toISOString()).optional(),
    currentPeriodEndDate: z.date().transform(v => v.toISOString()).optional(),
    neverExpires: z.boolean().optional(),
    numberOfBillingCycles: z.number().int().optional(),
    merchantApiKey: z.string().optional(),
    priceMoney: z.lazy(() =>
      GetClientSubscriptionsV1SearchPriceMoney$outboundSchema
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      planId: "plan_id",
      userId: "user_id",
      instrumentId: "instrument_id",
      billingCycleAnchor: "billing_cycle_anchor",
      priceAmount: "price_amount",
      priceCurrency: "price_currency",
      startDate: "start_date",
      trialStartDate: "trial_start_date",
      trialEndDate: "trial_end_date",
      cancelAtPeriodEnd: "cancel_at_period_end",
      canceledAt: "canceled_at",
      createdAt: "created_at",
      updatedAt: "updated_at",
      currentPeriodStartDate: "current_period_start_date",
      currentPeriodEndDate: "current_period_end_date",
      neverExpires: "never_expires",
      numberOfBillingCycles: "number_of_billing_cycles",
      merchantApiKey: "merchant_api_key",
      priceMoney: "price_money",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetClientSubscriptionsV1SearchSubscription$ {
  /** @deprecated use `GetClientSubscriptionsV1SearchSubscription$inboundSchema` instead. */
  export const inboundSchema =
    GetClientSubscriptionsV1SearchSubscription$inboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchSubscription$outboundSchema` instead. */
  export const outboundSchema =
    GetClientSubscriptionsV1SearchSubscription$outboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchSubscription$Outbound` instead. */
  export type Outbound = GetClientSubscriptionsV1SearchSubscription$Outbound;
}

export function getClientSubscriptionsV1SearchSubscriptionToJSON(
  getClientSubscriptionsV1SearchSubscription:
    GetClientSubscriptionsV1SearchSubscription,
): string {
  return JSON.stringify(
    GetClientSubscriptionsV1SearchSubscription$outboundSchema.parse(
      getClientSubscriptionsV1SearchSubscription,
    ),
  );
}

export function getClientSubscriptionsV1SearchSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<
  GetClientSubscriptionsV1SearchSubscription,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetClientSubscriptionsV1SearchSubscription$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetClientSubscriptionsV1SearchSubscription' from JSON`,
  );
}

/** @internal */
export const GetClientSubscriptionsV1SearchData$inboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchData,
  z.ZodTypeDef,
  unknown
> = z.object({
  subscriptions: z.array(
    z.lazy(() => GetClientSubscriptionsV1SearchSubscription$inboundSchema),
  ).optional(),
  count: z.string().optional(),
  direction: z.string().optional(),
  sort_by: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "sort_by": "sortBy",
  });
});

/** @internal */
export type GetClientSubscriptionsV1SearchData$Outbound = {
  subscriptions?:
    | Array<GetClientSubscriptionsV1SearchSubscription$Outbound>
    | undefined;
  count?: string | undefined;
  direction?: string | undefined;
  sort_by?: string | undefined;
};

/** @internal */
export const GetClientSubscriptionsV1SearchData$outboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchData$Outbound,
  z.ZodTypeDef,
  GetClientSubscriptionsV1SearchData
> = z.object({
  subscriptions: z.array(
    z.lazy(() => GetClientSubscriptionsV1SearchSubscription$outboundSchema),
  ).optional(),
  count: z.string().optional(),
  direction: z.string().optional(),
  sortBy: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    sortBy: "sort_by",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetClientSubscriptionsV1SearchData$ {
  /** @deprecated use `GetClientSubscriptionsV1SearchData$inboundSchema` instead. */
  export const inboundSchema = GetClientSubscriptionsV1SearchData$inboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchData$outboundSchema` instead. */
  export const outboundSchema =
    GetClientSubscriptionsV1SearchData$outboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchData$Outbound` instead. */
  export type Outbound = GetClientSubscriptionsV1SearchData$Outbound;
}

export function getClientSubscriptionsV1SearchDataToJSON(
  getClientSubscriptionsV1SearchData: GetClientSubscriptionsV1SearchData,
): string {
  return JSON.stringify(
    GetClientSubscriptionsV1SearchData$outboundSchema.parse(
      getClientSubscriptionsV1SearchData,
    ),
  );
}

export function getClientSubscriptionsV1SearchDataFromJSON(
  jsonString: string,
): SafeParseResult<GetClientSubscriptionsV1SearchData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetClientSubscriptionsV1SearchData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetClientSubscriptionsV1SearchData' from JSON`,
  );
}

/** @internal */
export const GetClientSubscriptionsV1SearchResponseBody$inboundSchema:
  z.ZodType<GetClientSubscriptionsV1SearchResponseBody, z.ZodTypeDef, unknown> =
    z.object({
      data: z.lazy(() => GetClientSubscriptionsV1SearchData$inboundSchema)
        .optional(),
    });

/** @internal */
export type GetClientSubscriptionsV1SearchResponseBody$Outbound = {
  data?: GetClientSubscriptionsV1SearchData$Outbound | undefined;
};

/** @internal */
export const GetClientSubscriptionsV1SearchResponseBody$outboundSchema:
  z.ZodType<
    GetClientSubscriptionsV1SearchResponseBody$Outbound,
    z.ZodTypeDef,
    GetClientSubscriptionsV1SearchResponseBody
  > = z.object({
    data: z.lazy(() => GetClientSubscriptionsV1SearchData$outboundSchema)
      .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetClientSubscriptionsV1SearchResponseBody$ {
  /** @deprecated use `GetClientSubscriptionsV1SearchResponseBody$inboundSchema` instead. */
  export const inboundSchema =
    GetClientSubscriptionsV1SearchResponseBody$inboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchResponseBody$outboundSchema` instead. */
  export const outboundSchema =
    GetClientSubscriptionsV1SearchResponseBody$outboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchResponseBody$Outbound` instead. */
  export type Outbound = GetClientSubscriptionsV1SearchResponseBody$Outbound;
}

export function getClientSubscriptionsV1SearchResponseBodyToJSON(
  getClientSubscriptionsV1SearchResponseBody:
    GetClientSubscriptionsV1SearchResponseBody,
): string {
  return JSON.stringify(
    GetClientSubscriptionsV1SearchResponseBody$outboundSchema.parse(
      getClientSubscriptionsV1SearchResponseBody,
    ),
  );
}

export function getClientSubscriptionsV1SearchResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  GetClientSubscriptionsV1SearchResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetClientSubscriptionsV1SearchResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetClientSubscriptionsV1SearchResponseBody' from JSON`,
  );
}

/** @internal */
export const GetClientSubscriptionsV1SearchResponse$inboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  Headers: z.record(z.array(z.string())),
  Result: z.lazy(() =>
    GetClientSubscriptionsV1SearchResponseBody$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "Headers": "headers",
    "Result": "result",
  });
});

/** @internal */
export type GetClientSubscriptionsV1SearchResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: GetClientSubscriptionsV1SearchResponseBody$Outbound;
};

/** @internal */
export const GetClientSubscriptionsV1SearchResponse$outboundSchema: z.ZodType<
  GetClientSubscriptionsV1SearchResponse$Outbound,
  z.ZodTypeDef,
  GetClientSubscriptionsV1SearchResponse
> = z.object({
  headers: z.record(z.array(z.string())),
  result: z.lazy(() =>
    GetClientSubscriptionsV1SearchResponseBody$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    headers: "Headers",
    result: "Result",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetClientSubscriptionsV1SearchResponse$ {
  /** @deprecated use `GetClientSubscriptionsV1SearchResponse$inboundSchema` instead. */
  export const inboundSchema =
    GetClientSubscriptionsV1SearchResponse$inboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchResponse$outboundSchema` instead. */
  export const outboundSchema =
    GetClientSubscriptionsV1SearchResponse$outboundSchema;
  /** @deprecated use `GetClientSubscriptionsV1SearchResponse$Outbound` instead. */
  export type Outbound = GetClientSubscriptionsV1SearchResponse$Outbound;
}

export function getClientSubscriptionsV1SearchResponseToJSON(
  getClientSubscriptionsV1SearchResponse:
    GetClientSubscriptionsV1SearchResponse,
): string {
  return JSON.stringify(
    GetClientSubscriptionsV1SearchResponse$outboundSchema.parse(
      getClientSubscriptionsV1SearchResponse,
    ),
  );
}

export function getClientSubscriptionsV1SearchResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetClientSubscriptionsV1SearchResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetClientSubscriptionsV1SearchResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetClientSubscriptionsV1SearchResponse' from JSON`,
  );
}
